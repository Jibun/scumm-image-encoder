import array
import os
import struct
from sie.sie_util import ScummImageEncoderException

DEBUG_DUMP = False

def readCommonColours(lflf_path):
    coloursPath = os.path.join(lflf_path, 'ROv1', 'BCv1')
    if not os.path.isfile(coloursPath):
        raise ScummImageEncoderException("Could not find v1 colours file at location %s.\n"
                                    "Remember to run 'v1col_extract' once on any V1 game resources." %
                                    coloursPath)
    coloursFile = file(coloursPath, 'rb')
    colours = list(struct.unpack('4B', coloursFile.read(4)))
    coloursFile.close()
    return colours

def readCharMap(lflf_path):
    charFile = file(os.path.join(lflf_path, 'ROv1', 'B1v1'), 'rb')
    #charMap = array.array('B')
    #charMap.fromstring(charFile.read())
    charMap = decodeC64Gfx(charFile, 2048)
    charFile.close()
    return charMap

def readPicMap(lflf_path, width, height):
    picFile = file(os.path.join(lflf_path, 'ROv1', 'B2v1'), 'rb')
    #picMap = array.array('B')
    #picMap.fromstring(picFile.read())
    picMap = decodeC64Gfx(picFile, width * height)
    picFile.close()
    return picMap

def readColourMap(lflf_path, width, height):
    colourFile = file(os.path.join(lflf_path, 'ROv1', 'B3v1'), 'rb')
    #colourMap = array.array('B')
    #colourMap.fromstring(colourFile.read())
    colourMap = decodeC64Gfx(colourFile, width * height)
    colourFile.close()
    return colourMap

def decodeV1Object(lflf_path, charMap, colours):
    pass

def decodeV1Bitmap(lflf_path, width, height):
    """
    Room format (offsets):
    probably starts with the size of the chunk.
    0x04 : 1 byte =  width?
    0x05 : 1 byte = height?
    0x06 - 0x09: 1 byte each = palette

    0x0A : 2 bytes = offset of charMap -> B1v1
    0x0C : 2 bytes = offset of picMap -> B2v1
    0x0E : 2 bytes = offset of colourMap
    0x10 : 2 bytes = offset of maskMap
    0x12 : 2 bytes = offset of maskChar
    
    0x15 : 1 byte = offset of box data

    charMap has output size of 2048.
    picMap, colourMap, and maskMap have an output size of width * height (I think).
    """
    global DEBUG_DUMP
    # This file requires running v1col_extract. Other files are generated by scummrp.
    colours = readCommonColours(lflf_path)
    charMap = readCharMap(lflf_path)
    picMap = readPicMap(lflf_path, width, height)
    colourMap = readColourMap(lflf_path, width, height)

    # Dump un-RLEed files
    if DEBUG_DUMP:
        charFile = file(os.path.join(lflf_path, 'charMap'), 'wb')
        charMap.tofile(charFile)
        charFile.close()
        picFile = file(os.path.join(lflf_path, 'picMap'), 'wb')
        picMap.tofile(picFile)
        picFile.close()
        colourFile = file(os.path.join(lflf_path, 'colourMap'), 'wb')
        colourMap.tofile(colourFile)
        colourFile.close()


    charIdx = None
    img_data = array.array('B', [0] * ((width * 8) * (height * 8)))
    dstPitch = width * 8
    # For each column strip number
    for x in xrange(width): # x is equivalent to stripnr
        # For every 8th row
        col_start = x * 8
        for y in xrange(height):
            colours[3] = (colourMap[y + x * height] & 7)

            charIdx = picMap[y + x * height] * 8
            # For each of the 8 rows
            for i in xrange(8):
                row_start = col_start + ((y * 8 + i) * dstPitch)
                c = charMap[charIdx + i]
                # For 8 columns
                for j in xrange(0, 8, 2):
                    # Each value is output twice - effectively means
                    #  you've got a half-width image.
                    val = colours[(c >> (6 - j)) & 3]
                    img_data[row_start + j] = val
                    img_data[row_start + j + 1] = val

    return img_data
    

def decodeC64Gfx(src, size):
    """This is an RLE variant."""

    x = None
    z = None
    colour = None
    run = None
    # Read the most common values
    common = struct.unpack('<4B', src.read(4))

    data = array.array('B')

    while len(data) < size:
        run, = struct.unpack('<B', src.read(1))
        if run & 0x80:
            colour = common[(run >> 5) & 3]
            run &= 0x1F
            for _ in xrange(run + 1):
                data.append(colour)
        elif run & 0x40:
            run &= 0x3F
            colour, = struct.unpack('<B', src.read(1))
            for _ in xrange(run + 1):
                data.append(colour)
        else:
            for _ in xrange(run + 1):
                colour, = struct.unpack('<B', src.read(1))
                data.append(colour)

    return data
